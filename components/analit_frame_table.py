import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import pandas as pd
from sqlalchemy import inspect
import threading

class AnalysisFrame(ttk.Frame):
    def __init__(self, master, df: pd.DataFrame, engine,table_name,query_executed):
        super().__init__(master)
        self.df = df
        self.table_name = table_name
        self.engine = engine
        self.columnconfigure(0, weight=1)
        self.rowconfigure(1, weight=1)
        self._create_widgets()

    def _create_widgets(self):
        # T√≠tulo
        header = ttk.Label(self, text="An√°lise de Tabela", font=("Arial", 14, "bold"))
        header.grid(row=0, column=0, pady=10, padx=10, sticky="w")

        # √Årea de texto com scroll
        self.text_area = tk.Text(self, wrap="none", height=20)
        self.text_area.grid(row=1, column=0, sticky="nsew", padx=10, pady=5)
        y_scroll = ttk.Scrollbar(self, orient="vertical", command=self.text_area.yview)
        y_scroll.grid(row=1, column=1, sticky="ns")
        self.text_area.configure(yscrollcommand=y_scroll.set)
        # Barra de progresso
        self.progress_bar = ttk.Progressbar(self, orient="horizontal", mode="indeterminate")
        self.progress_bar.grid(row=2, column=0, sticky="ew", padx=10, pady=5)

        # Bot√µes de an√°lise
        btn_frame = ttk.Frame(self)
        btn_frame.grid(row=2, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        btn_frame.columnconfigure((0, 1, 2, 3, 4), weight=1)
        
        ttk.Button(btn_frame, text="Cancelar An√°lise", command=self.cancel_analysis).grid(row=0, column=1, sticky="ew", padx=5)

        ttk.Button(btn_frame, text="Tipos de Dados", command=self.show_data_types).grid(row=0, column=0, sticky="ew", padx=5)
        ttk.Button(btn_frame, text="Ver Rela√ß√µes", command=self.show_table_relations).grid(row=0, column=1, sticky="ew", padx=5)
        ttk.Button(btn_frame, text="Mal Formados", command=self.show_malformed).grid(row=0, column=2, sticky="ew", padx=5)
        ttk.Button(btn_frame, text="Duplicados", command=self.show_duplicates).grid(row=0, column=3, sticky="ew", padx=5)
        ttk.Button(btn_frame, text="Exportar Excel", command=self.export_to_excel).grid(row=0, column=4, sticky="ew", padx=5)
        ttk.Button(btn_frame, text="Resumo Estat√≠stico", command=self.show_summary).grid(row=0, column=5, sticky="ew", padx=5)
        
    def cancel_analysis(self):
        self._stop_thread = True
        self.progress_bar.stop()
        self.update_text_area("An√°lise cancelada pelo usu√°rio.")
    
    def show_malformed(self):
        self._stop_thread = False
        self.progress_bar.start()
        threading.Thread(target=self.process_malformed, daemon=True).start()
    
    def show_summary(self):
        try:
            # Gera o resumo estat√≠stico
            summary_df = self.df.describe(include="all")

            # Come√ßa a compor o texto de sa√≠da com explica√ß√µes
            output = [
                "üìà **Resumo Estat√≠stico da Tabela:**\n",
                "Este resumo fornece uma vis√£o geral das colunas, incluindo contagens, valores √∫nicos, m√©dias, desvios padr√£o e outras estat√≠sticas importantes.\n",
                "Legenda das M√©tricas:\n",
                "‚Ä¢ count ‚Äî Quantidade de registros n√£o nulos (preenchidos)\n"
                "‚Ä¢ unique ‚Äî N√∫mero de valores √∫nicos (somente para colunas categ√≥ricas)\n"
                "‚Ä¢ top ‚Äî Valor mais frequente (moda)\n"
                "‚Ä¢ freq ‚Äî Quantidade de vezes que o valor mais frequente aparece\n"
                "‚Ä¢ mean ‚Äî M√©dia (somente para colunas num√©ricas)\n"
                "‚Ä¢ std ‚Äî Desvio padr√£o (dispers√£o dos dados)\n"
                "‚Ä¢ min ‚Äî Valor m√≠nimo\n"
                "‚Ä¢ 25% ‚Äî Primeiro quartil (25% dos dados abaixo desse valor)\n"
                "‚Ä¢ 50% ‚Äî Mediana (metade dos dados abaixo/acima)\n"
                "‚Ä¢ 75% ‚Äî Terceiro quartil (75% dos dados abaixo desse valor)\n"
                "‚Ä¢ max ‚Äî Valor m√°ximo\n\n",
                "üìä Estat√≠sticas por Coluna:\n"
            ]

            output.append(summary_df.to_string())

            self.update_text_area("\n".join(output))
        except Exception as e:
            self.handle_error("Erro ao gerar resumo", e)


    def update_text_area(self, text):
        self.text_area.config(state=tk.NORMAL)
        self.text_area.delete(1.0, tk.END)
        self.text_area.insert(tk.END, text)
        self.text_area.config(state=tk.DISABLED)
        self.text_area.see("1.0")

    def show_data_types(self):
        try:
            inspector = inspect(self.engine)
            columns = inspector.get_columns(self.table_name)

            if not columns:
                self.update_text_area("‚ùå Nenhuma coluna encontrada na tabela.")
                return

            text = "üìä Tipos de Dados:\n\n"
            for col in columns:
                name = col["name"]
                col_type = str(col["type"])
                text += f"‚Ä¢ {name}: {col_type}\n"

            self.update_text_area(text)
        except Exception as e:
            self.handle_error("Erro ao verificar tipos de dados", e)

    def show_table_relations(self):
        try:
            inspector = inspect(self.engine)
            foreign_keys = inspector.get_foreign_keys(self.table_name)
            result = []

            if not foreign_keys:
                result.append(f"üîç A tabela **'{self.table_name}'** n√£o possui rela√ß√µes com outras tabelas.")
            else:
                result.append(f"üîó **Rela√ß√µes Encontradas da Tabela '{self.table_name}':**\n")
                result.append("Essas s√£o as chaves estrangeiras (foreign keys) que indicam como esta tabela se conecta com outras no banco de dados.\n")
                
                for i, fk in enumerate(foreign_keys, start=1):
                    referred_table = fk['referred_table']
                    local_cols = ", ".join(fk['constrained_columns'])
                    remote_cols = ", ".join(fk['referred_columns'])
                    constraint_name = fk.get('name', 'sem nome')
                    result.append(
                        f"üî∏ Rela√ß√£o {i}:\n"
                        f"    ‚Ä¢ üîë Coluna(s) local(is): `{local_cols}`\n"
                        f"    ‚Ä¢ üóÉÔ∏è Referencia a tabela: `{referred_table}`\n"
                        f"    ‚Ä¢ üìå Coluna(s) na outra tabela: `{remote_cols}`\n"
                        f"    ‚Ä¢ üß© Nome da restri√ß√£o (constraint): `{constraint_name}`\n"
                    )

            self.update_text_area("\n".join(result))

        except Exception as e:
            self.handle_error("Erro ao verificar rela√ß√µes da tabela", e)



    # def show_malformed(self):
    #     try:
    #         # Verifica valores nulos
    #         null_summary = self.df.isnull().sum()

    #         # Verifica strings vazias (apenas em colunas do tipo objeto/string)
    #         empty_summary = self.df.select_dtypes(include="object").apply(
    #             lambda c: (c.astype(str).str.strip() == "")
    #         ).sum()

    #         # Monta resumo de colunas com dados malformados
    #         output = ["üìâ Resumo de Colunas com Valores Nulos ou Vazios:\n"]
    #         for col in self.df.columns:
    #             total_null = null_summary[col]
    #             total_empty = empty_summary.get(col, 0)
    #             if total_null > 0 or total_empty > 0:
    #                 output.append(f"‚Ä¢ {col}: {total_null} nulos, {total_empty} vazios")

    #         # Filtra linhas malformadas
    #         is_null = self.df.isnull().any(axis=1)
    #         is_empty = self.df.select_dtypes(include="object").apply(
    #             lambda c: c.astype(str).str.strip() == ""
    #         ).any(axis=1)
    #         malformed = self.df[is_null | is_empty]

    #         if not malformed.empty:
    #             output.append("\nüß™ Registros Mal Formados:\n")
    #             output.append(malformed.to_string(index=False))

    #             # Pergunta se deseja exportar
    #             save = messagebox.askyesno("Exportar?", "Deseja exportar os registros mal formados para Excel?")
    #             if save:
    #                 file_path = filedialog.asksaveasfilename(
    #                     defaultextension=".xlsx",
    #                     filetypes=[("Excel Files", "*.xlsx")],
    #                     title="Salvar Registros Mal Formados"
    #                 )
    #                 if file_path:
    #                     malformed.to_excel(file_path, index=False)
    #                     messagebox.showinfo("Exporta√ß√£o", f"Arquivo salvo com sucesso:\n{file_path}")
    #         else:
    #             output.append("\n‚úÖ Nenhum registro mal formado encontrado.")

    #         self.update_text_area("\n".join(output))
    #     except Exception as e:
    #         self.handle_error("Erro ao verificar registros mal formados", e)


    def show_duplicates(self):
        try:
            if self.df.empty:
                self.update_text_area("‚ùå O DataFrame est√° vazio.")
                return

            duplicated = self.df[self.df.duplicated(keep=False)]

            if duplicated.empty:
                self.update_text_area("‚úÖ Nenhum registro duplicado encontrado.")
                return

            output = [f"‚ö†Ô∏è {len(duplicated)} registros duplicados encontrados:\n"]

            # Mostrar os duplicados agrupados
            grouped = duplicated.groupby(list(self.df.columns)).size().reset_index(name='Ocorr√™ncias')
            output.append("üìå Registros Duplicados Agrupados:\n")
            output.append(grouped.to_string(index=False))
            output.append("")

            # Verificar colunas que causam duplicatas
            output.append("üîç Colunas com maior contribui√ß√£o para duplica√ß√µes:\n")
            for col in self.df.columns:
                dup_col = self.df[self.df.duplicated(subset=[col], keep=False)]
                if not dup_col.empty:
                    output.append(f"‚Ä¢ {col} ‚Üí {len(dup_col)} registros duplicados por essa coluna")

            self.update_text_area("\n".join(output))
        except Exception as e:
            self.handle_error("Erro ao verificar duplicatas", e)
    
    def process_malformed(self):
        try:
            # Verifica valores nulos
            null_summary = self.df.isnull().sum()

            # Verifica strings vazias (apenas em colunas do tipo objeto/string)
            empty_summary = self.df.select_dtypes(include="object").apply(
                lambda c: (c.astype(str).str.strip() == "")
            ).sum()

            # Monta resumo de colunas com dados malformados
            output = ["üìâ Resumo de Colunas com Valores Nulos ou Vazios:\n"]
            for col in self.df.columns:
                total_null = null_summary[col]
                total_empty = empty_summary.get(col, 0)
                if total_null > 0 or total_empty > 0:
                    output.append(f"‚Ä¢ {col}: {total_null} nulos, {total_empty} vazios")

            # Filtra linhas malformadas
            is_null = self.df.isnull().any(axis=1)
            is_empty = self.df.select_dtypes(include="object").apply(
                lambda c: c.astype(str).str.strip() == ""
            ).any(axis=1)
            malformed = self.df[is_null | is_empty]

            if not malformed.empty:
                output.append("\nüß™ Registros Mal Formados:\n")
                output.append(malformed.to_string(index=False))

                # Pergunta se deseja exportar
                save = messagebox.askyesno("Exportar?", "Deseja exportar os registros mal formados para Excel?")
                if save:
                    file_path = filedialog.asksaveasfilename(
                        defaultextension=".xlsx",
                        filetypes=[("Excel Files", "*.xlsx")],
                        title="Salvar Registros Mal Formados"
                    )
                    if file_path:
                        malformed.to_excel(file_path, index=False)
                        messagebox.showinfo("Exporta√ß√£o", f"Arquivo salvo com sucesso:\n{file_path}")
            else:
                output.append("\n‚úÖ Nenhum registro mal formado encontrado.")

            # Atualiza a √°rea de texto com o resumo
            self.update_text_area("\n".join(output))
        except Exception as e:
            self.handle_error("Erro ao verificar registros mal formados", e)
        finally:
            # Para a barra de progresso quando o processo for conclu√≠do
            if not self._stop_thread:
                self.progress_bar.stop()

    def handle_error(self, title, error):
        messagebox.showerror(title, str(error))


    def export_to_excel(self):
        try:
            file_path = filedialog.asksaveasfilename(
                defaultextension=".xlsx",
                initialfile=f"{self.table_name}_analise.xlsx",
                filetypes=[("Excel Files", "*.xlsx")]
            )
            if not file_path:
                return
            self.df.to_excel(file_path, index=False)
            messagebox.showinfo("Exporta√ß√£o", f"Arquivo salvo com sucesso:\n{file_path}")
        except Exception as e:
            self.handle_error("Erro ao exportar", e)

    def handle_error(self, title, error):
        messagebox.showerror(title, str(error))
